from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from database import db, User, Client, Order, Product
import io
import csv
from datetime import datetime
from sqlalchemy import func, extract
from werkzeug.security import generate_password_hash, check_password_hash
from fpdf import FPDF # NOVO: Importação para gerar PDF

app = Flask(__name__)

# String de conexão do banco de dados corrigida com usuário, senha e porta
app.config["SQLALCHEMY_DATABASE_URI"] = "postgresql://bwqQCWau3ybME2RR:6XHFzssSRgbjzIMUZat3i557497Zcr38@localhost:5433/gbl"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

db.init_app(app)
CORS(app)

# --- Rotas de Autenticação ---
@app.route("/api/login", methods=["POST"])
def login():
    data = request.get_json()
    username = data.get("username")
    password = data.get("password")

    user = User.query.filter_by(username=username).first()

    if user and check_password_hash(user.password, password):
        return jsonify({"message": "Login bem-sucedido!", "user": {"username": user.username, "role": user.role}}), 200
    return jsonify({"message": "Credenciais inválidas"}), 401

# --- Rotas de Clientes ---
@app.route("/api/clients", methods=["GET"])
def get_clients():
    clients = Client.query.all()
    return jsonify([{
        "id": c.id, "name": c.name, "contact_person": c.contact_person,
        "phone": c.phone, "email": c.email, "address": c.address,
        "cnpj": c.cnpj, "observations": c.observations,
        "created_at": c.created_at.isoformat() if c.created_at else None
    } for c in clients])

@app.route("/api/clients", methods=["POST"])
def add_client():
    data = request.get_json()
    if not data.get("name"):
        return jsonify({"message": "Nome do cliente é obrigatório"}), 400
    new_client = Client(
        name=data["name"], contact_person=data.get("contact_person"),
        phone=data.get("phone"), email=data.get("email"),
        address=data.get("address"), cnpj=data.get("cnpj"),
        observations=data.get("observations")
    )
    try:
        db.session.add(new_client)
        db.session.commit()
        return jsonify({"message": "Cliente adicionado com sucesso!", "client": {
            "id": new_client.id, "name": new_client.name, "contact_person": new_client.contact_person,
            "phone": new_client.phone, "email": new_client.email, "address": new_client.address,
            "cnpj": new_client.cnpj, "observations": new_client.observations,
            "created_at": new_client.created_at.isoformat()
        }}), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({"message": f"Erro ao adicionar cliente: {str(e)}"}), 500

@app.route('/api/clients/export', methods=['GET'])
def export_clients():
    try:
        clients = Client.query.all()
        output = io.StringIO()
        writer = csv.writer(output)
        headers = ['ID', 'Nome', 'Pessoa de Contato', 'Telefone', 'Email', 'Endereço', 'CNPJ', 'Observações', 'Criado Em']
        writer.writerow(headers)
        for client in clients:
            writer.writerow([
                client.id, client.name, client.contact_person, client.phone, client.email,
                client.address, client.cnpj, client.observations,
                client.created_at.isoformat() if client.created_at else ''
            ])
        csv_data = output.getvalue()
        output.close()
        return send_file(
            io.BytesIO(csv_data.encode('utf-8')), mimetype='text/csv', as_attachment=True,
            download_name=f'clientes_exportados_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        )
    except Exception as e:
        return jsonify({'message': f'Erro ao exportar clientes: {str(e)}'}), 500

@app.route('/api/clients/import', methods=['POST'])
def import_clients():
    if 'file' not in request.files: return jsonify({'message': 'Nenhum arquivo enviado'}), 400
    file = request.files['file']
    if file.filename == '': return jsonify({'message': 'Nenhum arquivo selecionado'}), 400
    if not file.filename.endswith('.csv'): return jsonify({'message': 'Formato de arquivo inválido. Apenas CSV é permitido.'}), 400
    try:
        stream = io.StringIO(file.stream.read().decode("UTF8"))
        reader = csv.reader(stream)
        header = next(reader, None)
        if not header: return jsonify({'message': 'Arquivo CSV vazio ou sem cabeçalho'}), 400
        column_mapping = {
            'ID': 'id', 'Nome': 'name', 'Pessoa de Contato': 'contact_person',
            'Telefone': 'phone', 'Email': 'email', 'Endereço': 'address',
            'CNPJ': 'cnpj', 'Observações': 'observations', 'Criado Em': 'created_at'
        }
        mapped_indices = {col_name: header.index(csv_header) for csv_header, col_name in column_mapping.items() if csv_header in header}
        imported_count = 0; updated_count = 0; errors = []
        for row_num, row in enumerate(reader):
            if not row: continue
            client_data = {};
            for model_col, idx in mapped_indices.items():
                if idx < len(row): client_data[model_col] = row[idx]
            for key in ['contact_person', 'email', 'phone', 'address', 'cnpj', 'observations']:
                if key not in client_data or client_data[key] == '': client_data[key] = None
            if 'created_at' in client_data and client_data['created_at']:
                try: client_data['created_at'] = datetime.fromisoformat(client_data['created_at'])
                except ValueError: errors.append(f"Linha {row_num + 2}: Formato de data inválido para 'Criado Em'."); continue
            existing_client = None
            if 'id' in client_data and client_data['id']:
                try: existing_client = Client.query.get(int(client_data['id']))
                except ValueError: errors.append(f"Linha {row_num + 2}: ID inválido '{client_data['id']}'."); continue
            if not existing_client and 'name' in client_data and client_data['name']:
                existing_client = Client.query.filter_by(name=client_data['name']).first()
            if existing_client:
                for key, value in client_data.items():
                    if key != 'id': setattr(existing_client, key, value)
                updated_count += 1
            else:
                if 'id' in client_data: del client_data['id']
                if not client_data.get('name'): errors.append(f"Linha {row_num + 2}: Nome do cliente é obrigatório e não fornecido."); continue
                new_client = Client(**client_data)
                db.session.add(new_client)
                imported_count += 1
        db.session.commit()
        response_message = f"Importação concluída. Novos clientes: {imported_count}, Clientes atualizados: {updated_count}."
        if errors: response_message += f" Erros encontrados: {len(errors)}. Verifique os logs para detalhes."; print("Erros de importação:", errors)
        return jsonify({'message': response_message, 'errors': errors}), 200
    except Exception as e:
        db.session.rollback()
        print(f"Erro inesperado durante a importação: {str(e)}")
        return jsonify({'message': f'Erro inesperado durante a importação: {str(e)}'}), 500

# --- Rotas de Produtos ---
@app.route("/api/products", methods=["GET"])
def get_products():
    products = Product.query.all()
    return jsonify([{
        "id": p.id, "name": p.name, "description": p.description,
        "price": p.price, "unit": p.unit, "sku": p.sku,
        "stock": p.stock,
        "created_at": p.created_at.isoformat() if p.created_at else None
    } for p in products])

@app.route("/api/products", methods=["POST"])
def add_product():
    data = request.get_json()
    if not data.get("name") or not data.get("price"):
        return jsonify({"message": "Nome e preço do produto são obrigatórios"}), 400
    try:
        new_product = Product(
            name=data["name"], description=data.get("description"),
            price=float(str(data["price"]).replace(',', '.')),
            unit=data.get("unit"), sku=data.get("sku"),
            stock=int(data.get("stock", 0))
        )
        db.session.add(new_product)
        db.session.commit()
        return jsonify({"message": "Produto adicionado com sucesso!", "product": {
            "id": new_product.id, "name": new_product.name, "description": new_product.description,
            "price": new_product.price, "unit": new_product.unit, "sku": new_product.sku,
            "stock": new_product.stock,
            "created_at": new_product.created_at.isoformat()
        }}), 201
    except ValueError:
        db.session.rollback()
        return jsonify({"message": "Formato de preço ou estoque inválido."
